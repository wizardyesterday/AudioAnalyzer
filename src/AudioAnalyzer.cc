//************************************************************************
// file name: AudioAnalyzer.cc
//************************************************************************
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>
#include <string.h>

#include "AudioAnalyzer.h"

using namespace std;

/*****************************************************************************

  Name: XErrorCallback

  Purpose: The purpose of this function is to to handle errors that
  are generated by X.

  Calling Sequence: XErrorCallback(displayPtr,errorPtr)
 
  Inputs:

    displayPtr - A pointer to the display for which the error was
    generated.

    errorPtr - A pointer to the error event for which the error
    was generated.

 Outputs:

    None.

*****************************************************************************/
static int XErrorCallback(Display *displayPtr,XErrorEvent *errorPtr)
{
  char msg[80];

  // Retrieve the error text
  XGetErrorText (displayPtr,errorPtr->error_code,msg,80);

  // Display the error message to the user.
  fprintf(stderr,"%s\n",msg);

  return (0);

} // XErrorCallback

/*****************************************************************************

  Name: AudioAnalyzer

  Purpose: The purpose of this function is to serve as the constructor for
  an instance of an AudioAnalyzer.

  Calling Sequence: AudioAnalyzer(displayTypesampleRate,baselineInDb))
 
  Inputs:

    displayType - The type of analyzer display.

    sampleRate - The sample rate of incoming IQ data in units of S/s.
    
    baselineInDb - The spectrum analyzer reference level in decibels.

 Outputs:

    None.

*****************************************************************************/
AudioAnalyzer::AudioAnalyzer(
  DisplayType displayType,
  float sampleRate,
  int32_t baselineInDb)
{
  uint32_t i;

  // Spectrum display baseline.
  this->baselineInDb = baselineInDb;

  if (sampleRate <= 0)
  {
    // Keep it sane.
    sampleRate = 8000;
  } // if

  // Retrieve for later use.
  this->displayType = displayType;

  // This is the display dimensions in pixels.
  windowWidthInPixels = 1024;
  windowHeightInPixels = 256;

  // Set strides.
  spectrumStride = (N/2) / windowWidthInPixels;
  signalStride = N / windowWidthInPixels;

  // Construct the Hanning window array.
  for (i = 0; i < N; i++)
  {
    hanningWindow[i] = 0.5 - 0.5 * cos((2 * M_PI * i)/N);
  } // for

  // Set up the FFT stuff.
  initializeFftw();

  // Do all the cool stuff for X.
  initializeX();

  // This sets up information stuff on the scopes.
  initializeAnnotationParameters(sampleRate);

  return;

} // AudioAnalyzer

/*****************************************************************************

  Name: ~AudioAnalyzer

  Purpose: The purpose of this function is to serve as the destructor for
  an instance of an AudioAnalyzer.

  Calling Sequence: ~AudioAnalyzer()

  Inputs:

    None.

  Outputs:

    None.

*****************************************************************************/
AudioAnalyzer::~AudioAnalyzer(void)
{

  // We're done with this display.
  XCloseDisplay(displayPtr);

  // Release FFT resources.
  fftw_destroy_plan(fftPlan);
  fftw_free(fftInputPtr);
  fftw_free(fftOutputPtr);

  return;

} // ~AudioAnalyzer

/*****************************************************************************

  Name: initializeFftw

  Purpose: The purpose of this function is to initialize FFTW so that
  FFT's can be performed.

  Calling Sequence: initializeFftw()

  Inputs:

    None.

 Outputs:

    None.

*****************************************************************************/
void AudioAnalyzer::initializeFftw(void)
{
  uint32_t i;

  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
  // This block of code sets up FFTW for a size of 8192 points.  This
  // is the result of N being defined as 8192.
  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
  fftInputPtr = (fftw_complex *)fftw_malloc(sizeof(fftw_complex)*N);
  fftOutputPtr = (fftw_complex *)fftw_malloc(sizeof(fftw_complex)*N);

  fftPlan = fftw_plan_dft_1d(N,fftInputPtr,fftOutputPtr,
                             FFTW_FORWARD,FFTW_ESTIMATE);
  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

  return;

} // initializeFftw

/*****************************************************************************

  Name: initializeX

  Purpose: The purpose of this function is to perform all of the
  initialization that is related to launching an X application.

  Note: For a 16-bit display, the partitioning of the color values
  are as follows (with r = red, g = green, blue = blue):

  r[4:0], g[5:0], blue[4:0] = rrrrr gggggg bbbbb = 16 bits

  Calling Sequence: initializeX()

  Inputs:

    None.

 Outputs:

    None.

*****************************************************************************/
void AudioAnalyzer::initializeX(void)
{
  int blackColor;
  int whiteColor;
  XEvent event;

  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
  // Initialize colors.  These colors will throughout
  // the application.
  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
  // Background is midnight blue.
  scopeBackgroundColor = convertRgbTo16Bit(25,25,112);

  // Grid is yellow.
  scopeGridColor = convertRgbTo16Bit(255,255,0);

  // Signal is green.
  scopeSignalColor = convertRgbTo16Bit(0,255,0);
  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
  // Setup X.
  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
  // Register the X error handler.
  XSetErrorHandler(XErrorCallback);

  // Connect to the X server.
  displayPtr = XOpenDisplay(NULL);

  // Retrieve these two colors.
  blackColor = BlackPixel(displayPtr,DefaultScreen(displayPtr));
  whiteColor = WhitePixel(displayPtr,DefaultScreen(displayPtr));

  // Create the window.
  window = XCreateSimpleWindow(displayPtr,
                               DefaultRootWindow(displayPtr),
                               0,
                               0, 
                               windowWidthInPixels,
                               windowHeightInPixels,
                               0,
                               blackColor,
                               scopeBackgroundColor);

  // We want to get MapNotify events.
  XSelectInput(displayPtr,window,StructureNotifyMask);

  // Create a "Graphics Context".
  graphicsContext = XCreateGC(displayPtr,window,0,NULL);

  // First-time foreground is whit.
  XSetForeground(displayPtr,graphicsContext,whiteColor);

  switch (displayType)			
  {
    case SignalMagnitude:
    {
      XStoreName(displayPtr,window,"Oscilloscope");
      break;
    } // case

    case PowerSpectrum:
    {
      XStoreName(displayPtr,window,"Spectrum Analyzer");
      break;
    } // case

    default:
    {
      XStoreName(displayPtr,window,"Signal Analyzer");
      break;
    } // case
  } // switch

  // "Map" the window (that is, make it appear on the screen).
  XMapWindow(displayPtr,window);

  // Wait for the MapNotify event.
  for(;;)
  {
    XNextEvent(displayPtr, &event);

    if (event.type == MapNotify)
    {
      break;
    } // if);
  } // for
  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/


  // Send the request to the server
  XFlush(displayPtr);
 
  return;

} // initializeX

/*****************************************************************************

  Name: initializeAnnotationParameters

  Purpose: The purpose of this function is to set up the scope annotations.
  Examples are sweep time and frequency span.

  Calling Sequence: initializeAnnotationParameters(sampleRate)

  Inputs:

    sampleRate - The sample rate of incoming PCM data in units of S/s.

 Outputs:

    None.

*****************************************************************************/
void AudioAnalyzer::initializeAnnotationParameters(float sampleRate)
{
  float sweepTimeInMs;
  float frequencySpanInHz;
  int fontHeight;
  int fontWidth;
  XFontStruct *fontInfoPtr;

  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
  // This is our font stuff.  By experiment, I see that
  // fixed fonts are 9 pixels high and 6 pixels wide.  Now,
  // the starting horizontal postion of the annotations is
  // 180 pixels to the left or the right boundary of the
  // window.  That means that the maximum amount of
  // characters is 180 / 6 = 30 - some spare change = 29
  // characters.  Not too shoddy.  If you need more, just
  // adjust the number.
  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
  // This is deterministic with respect to size.
  fontInfoPtr = XLoadQueryFont(displayPtr,"fixed");

  XSetFont(displayPtr,
           graphicsContext,
           fontInfoPtr->fid);

  // Compute the height and width of the font.
  fontHeight = fontInfoPtr->ascent - fontInfoPtr->descent;
  fontWidth = XTextWidth(fontInfoPtr,"A",strlen("A"));

  // Set our vertical positions of the annotations.
  annotationFirstLinePosition = fontHeight + 6;
  annotationSecondLinePosition = annotationFirstLinePosition + 15;

  //-------------------------------------------------------
  // This is where the annotation will start.  Remember
  // that you can have (180 / 6) - 1 = 29 characters.
  // This is where you adjust things.  Also remember
  // that, for a fixed font, the pixel height is 9 pixels,
  // and the pixel width is 6 pixels.  This will save you
  // lots of grief when adjusting things.
  //-------------------------------------------------------
  annotationHorizontalPosition = windowWidthInPixels - 180;
  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
  // Set up annotations.
  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
  // Compute sweep time in milliseconds.
  sweepTimeInMs = N / sampleRate;
  sweepTimeInMs *= 1000;

  // Compute frequency span in kHz.
  frequencySpanInHz = sampleRate / 2;

  // Save in buffers to be displayed in oscilloscope.
  sprintf(sweepTimeBuffer,"Sweep Time: %.2fms",sweepTimeInMs);
  sprintf(sweepTimeDivBuffer,"%.2fms/div",sweepTimeInMs/16);

  // Save in buffers to be displayed in spectrum analyzer.
  sprintf(frequencySpanBuffer,"Frequency Span: %.2fHz",frequencySpanInHz);
  sprintf(frequencySpanDivBuffer,"%.2fHz/div",frequencySpanInHz/16);
  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

  return;

} // initialize annotationParameters

/*****************************************************************************

  Name: convertRgbTo16Bit

  Purpose: The purpose of this function is to convert an rgb triple into
  a value that is suitable for 16-bit displays.

  Note: For a 16-bit display, the partitioning of the color values
  are as follows (with r = red, g = green, blue = blue):

  r[4:0], g[5:0], blue[4:0] = rrrrr gggggg bbbbb = 16 bits

  Calling Sequence: value = convertRgbTo16Bit(red,green,blue)

  Inputs:

    red - The red contribution [0,255].

    green - The green contribution [0,255].

    blue - The blue contribution [0,255].

  Outputs:

    value = The 16-bit representation of the rgb value.

*****************************************************************************/
uint16_t AudioAnalyzer::convertRgbTo16Bit(
  uint8_t red,
  uint8_t green,
  uint8_t blue)
{
  uint16_t value;
  uint16_t r, g, b;

  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
  // Form the quantized values.
  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
  // Quantize to 5 bits.
  r = red / 8;

  // Quantize to 6 bits.
  g = green / 4;

  // Quantize to 5 bits.
  b = blue / 8;
  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

  // Construct the 16-bit value.
  value = (r << 11) | (g << 5) | b;
  
  return (value);

} // convertRgbTo16Bit

/*****************************************************************************

  Name: drawGridlines

  Purpose: The purpose of this function is to draw a grid on the
  analyzer display.

  Calling Sequence: drawGridlines()

  Inputs:

    None.

 Outputs:

    None.

*****************************************************************************/
void AudioAnalyzer::drawGridlines(void)
{
  uint32_t i;
  int deltaH;
  int deltaV;
  int horizontalPosition;
  int verticalPosition;

  // Compute grid spacing.
  deltaH = windowWidthInPixels / 16;
  deltaV = windowHeightInPixels / 4;

  // Set the grid color.
  XSetForeground(displayPtr,graphicsContext,scopeGridColor);

  // Compute horizontal position of first vertical grid.
  horizontalPosition = deltaH;

  // Draw vertical lines.
  for (i = 1; i < 16; i++)
  {
    XDrawLine(displayPtr,
              window,
              graphicsContext,
              horizontalPosition,
              0,
              horizontalPosition,
              windowHeightInPixels);

    // Compute next horizontal position of vertical grid.
    horizontalPosition += deltaH;
  } // for

  // Compute vertical position of first horizontal grid.
  verticalPosition = deltaV;

  // Draw horozontal lines.
  for (i = 1; i < 4; i++)
  {
    XDrawLine(displayPtr,
              window,
              graphicsContext,
              0,
              verticalPosition,
              windowWidthInPixels,
              verticalPosition);

    // Compute next horizontal position of vertical grid.
    verticalPosition += deltaV;
  } // for

  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
  // Nicely mark the horizontal center.
  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

  //---------------------------------
  // Place marks on upper part of
  // screen.
  //---------------------------------
  XDrawLine(displayPtr,
            window,
            graphicsContext,
            (windowWidthInPixels/2) - 1,
            0,
            (windowWidthInPixels/2) - 1,
            5);

  XDrawLine(displayPtr,
            window,
            graphicsContext,
            (windowWidthInPixels/2) + 1,
            0,
            (windowWidthInPixels/2) + 1,
            5);

  //---------------------------------
  // Place marks on lower part of
  // screen.
  //---------------------------------
  XDrawLine(displayPtr,
            window,
            graphicsContext,
            (windowWidthInPixels/2) - 1,
            windowHeightInPixels-5,
            (windowWidthInPixels/2) - 1,
            windowHeightInPixels);

  XDrawLine(displayPtr,
            window,
            graphicsContext,
            (windowWidthInPixels/2) + 1,
            windowHeightInPixels-5,
            (windowWidthInPixels/2) + 1,
            windowHeightInPixels);

  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

  // Send the request to the server
  XFlush(displayPtr);
 
  return;

} // drawGridLines

/*****************************************************************************

  Name: plotSignalAmplitude

  Purpose: The purpose of this function is to perform an amplitude plot
  of PCM data.

  Calling Sequence: plotSignalAmplitude(signalBufferPtr,bufferLength)

  Inputs:

    signalBufferPtr - A pointer to a buffer of PCM data.

    bufferLength - The number of values in the signal buffer.

 Outputs:

    None.

*****************************************************************************/
void AudioAnalyzer::plotSignalAmplitude(
  int16_t *signalBufferPtr,
  uint32_t bufferLength)
{
  uint32_t i;
  uint32_t j;

  // Reference the start of the points array.
  j = 0;

  // We're fitting 8192 PCM samples to the display width.
  for (i = 0; i < bufferLength; i += signalStride)
  {
    points[j].x = (short)j;
    points[j].y = (windowHeightInPixels / 2) - (signalBufferPtr[i] / 256);

    // Reference the next storage location.
    j++;
  } // for

  // Erase the previous plot.
  XClearWindow(displayPtr,window);

  // Make this display pretty.
  drawGridlines();

  // Set the signal color.
  XSetForeground(displayPtr,graphicsContext,scopeSignalColor);

  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
  // Annotate the display.  This is really too
  // sensitive to fonts.  I'll think of something
  // later.
  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
  XDrawString(displayPtr,window,graphicsContext,
              annotationHorizontalPosition,
              annotationFirstLinePosition,
              sweepTimeBuffer,strlen(sweepTimeBuffer));

  XDrawString(displayPtr,window,graphicsContext,
              annotationHorizontalPosition,
              annotationSecondLinePosition,
              sweepTimeDivBuffer,strlen(sweepTimeDivBuffer));
  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

  // Plot the signal.
  XDrawLines(displayPtr,
             window,
             graphicsContext,
             points,windowWidthInPixels,
             CoordModeOrigin);

  // Send the request to the server
  XFlush(displayPtr);

  return;

} // plotSignalAmplitude

/*****************************************************************************

  Name: plotPowerSpectrum

  Purpose: The purpose of this function is to perform a power spectrum plot
  of IQ data to the display.

  Calling Sequence: plotPowerSpectrum(signalBufferPtr,bufferLength)

  Inputs:

    signalBufferPtr - A pointer to a buffer of IQ data.  The buffer is
    formatted with interleaved data as: I1,Q1,I2,Q2,...

    bufferLength - The number of values in the signal buffer.  This
    represents the total number of items in the buffer, rather than
    the number of IQ sample pairs in the buffer.

 Outputs:

    None.

*****************************************************************************/
void AudioAnalyzer::plotPowerSpectrum(
  int16_t *signalBufferPtr,
  uint32_t bufferLength)
{
  uint32_t i;
  uint32_t j;

  bufferLength = computePowerSpectrum(signalBufferPtr,bufferLength);

  // Reference the start of the points array.
  j = 0;

  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
  // We're fitting the first half of a 8192-point FFT to 
  // the display width.
  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
  for (i = 0; i < bufferLength; i += spectrumStride)
  {
    points[j].x = (short)j;
    points[j].y = windowHeightInPixels - magnitudeBuffer[i];

    // Reference the next storage location.
    j++;
  } // for

  // Erase the previous plot.
  XClearWindow(displayPtr,window);

  // Make this display pretty.
  drawGridlines();

  // Set the signal color.
  XSetForeground(displayPtr,graphicsContext,scopeSignalColor);

  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
  // Annotate the display.  This is really too
  // sensitive to fonts.  I'll think of something
  // later.
  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
  XDrawString(displayPtr,window,graphicsContext,
              annotationHorizontalPosition,
              annotationFirstLinePosition,
              frequencySpanBuffer,strlen(frequencySpanBuffer));

  XDrawString(displayPtr,window,graphicsContext,
              annotationHorizontalPosition,
              annotationSecondLinePosition,
              frequencySpanDivBuffer,strlen(frequencySpanDivBuffer));
  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

  // Plot the signal.
  XDrawLines(displayPtr,
             window,
             graphicsContext,
             points,windowWidthInPixels,
             CoordModeOrigin);

  // Send the request to the server
  XFlush(displayPtr);

  return;

} // plotPowerSpectrum

/*****************************************************************************

  Name: computePowerSpectrum

  Purpose: The purpose of this function is to compute the power spectrum
  of IQ data.

  Calling Sequence: computePowerSpectrum(signalBufferPtr,bufferLength)

  Inputs:

    signalBufferPtr - A pointer to a buffer of IQ data.  The buffer is
    formatted with interleaved data as: I1,Q1,I2,Q2,...

    bufferLength - The number of values in the signal buffer.  This
    represents the total number of items in the buffer.

 Outputs:

    None.

*****************************************************************************/
uint32_t AudioAnalyzer::computePowerSpectrum(
  int16_t *signalBufferPtr,
  uint32_t bufferLength)
{
  uint32_t i;
  int16_t iMagnitude, qMagnitude;
  double power;
  double powerInDb;
  double iK;

  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
  // Fill up the input array.  The second index of the
  // array is used as follows: a value of 0 references
  // the real component of the signal, and a value of 1
  // references the imaginary component of the signal.
  // Each component is windowed so that sidelobes are
  // reduced.
  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
  for (i = 0; i < bufferLength; i++)
  {
    // Store the real value.
    fftInputPtr[i][0] = (double)signalBufferPtr[i] * hanningWindow[i];

    // Store the imaginary value.
    fftInputPtr[i][1] = 0;;
  } // for
  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

  // Compute the DFT.
  fftw_execute(fftPlan);

  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
  // Compute the magnitude of the spectrum in decibels.
  // Originally, I used a simple approximation for the
  // magnitude, but the result was a lousy display of the
  // spectrum.
  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
  for (i = 0; i < N/2; i++)
  {
    // Retrive the in-phase and quadrature parts.
    iK = fftOutputPtr[i][0];

    // Compute signal power, |I + jQ|.
    power = iK * iK;

    // Scale for a normalized output.
    power /= N;

    // We want power in decibels.
    powerInDb = 10*log10(power);

    // Set the baseline to the reference level..
    powerInDb += baselineInDb;

    // Scale to display 20dB per division.
    powerInDb *= 3.2;

    // We're reusing the magnitude buffer for power values.
    magnitudeBuffer[i] = (int16_t)powerInDb; 
  } // for
  //_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

  return (bufferLength/2);

} // computePowerSpectrum


